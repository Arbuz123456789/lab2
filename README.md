## Отчет по лабораторной работе № 2

#### № группы: ПМ-2502

#### Выполнил: Друзин Дмитрий Иванович

#### Вариант: 5  

### Cодержание:

- [Задача 1](#1-задача-1)
- [Задача 2](#2-задача-2)
- [Задача 3](#3-задача-3)
- [Задача 4](#4-задача-4)

### 1. Задача 1

#### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ решения](#6-анализ-решения)

#### 1. Постановка задачи
Дана последовательность, которая строится по определенному закону на основе начального значения a₀. Необходимо:

- Определить закономерность построения последовательности

- Запрограммировать генерацию последовательности для заданных a₀ и n

#### 2. Входные и выходные данные
##### Данные на вход
|    | Тип               | min значение | max значение |
|----|-------------------|--------------|--------------|
| a₀ | Целое число       | Любое целое  |              |
| n  | Натуральное число |    0         |     100      |

##### Данные на выход
|           | Тип    | Описание                             |
|-----------|--------|--------------------------------------|
| a₀        | Строка | Нулевой член                         |
| a₁...aₙ   | Строка | Следующие n членов последовательности|

#### 3. Выбор структуры данных
##### 1. Анализ: 
Для хранения последовательности нужен массив или список. Так как n < 100, можно использовать массив.

##### 2. Структура данных:
- Переменная типа int для текущего члена последовательности
- Массив типа int для хранения сгенерированных членов
-Переменные для хранения входных данных: a₀, n

#### 4. Алгоритм
##### 1. Ввод данных:
- Считать a₀
- Считать n

##### 2. Инициализация:
   - current = a₀
   - Создать массив результатов длиной n

##### 3. Обработка последовательности (для i от 1 до n-1):
- Если current четное:
  - next = current / 2
-Иначе:
  - next = current * 3 + 2
- Сохранить next в массив результатов
- current = next

##### 4. Вывод результата:
- Вывести "a_0: " + a₀
- Вывести элементы массива через запятую

#### 5. Программа
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("a₀ (нулевой член): ");
        int a0 = scanner.nextInt();
        System.out.print("n (число следующих членов): ");
        int n = scanner.nextInt();
        if (n <= 0 || n >= 100) {
            System.out.println("Ошибка: n должно быть в диапазоне 0 < n < 100");
            return;
        }
        int[] sequence = new int[n];
        int current = a0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                current = current + 5;
            } else {
                current = current / 2;
            }
            sequence[i] = current;
        }
        System.out.println("$ a_0: " + a0);
        System.out.print("a_1...a_" + n + ":\n");
        for (int i = 0; i < n; i++) {
            System.out.print(sequence[i]);
            if (i < n - 1) {
                System.out.print(", ");
            }
        }
        System.out.println();
        scanner.close();
    }
}
```
#### 6. Анализ решения:
Программа корректно работает для всех случаев:

1. Тест: a₀ = 10, n = 10
  - Input:

10 10

  - Output:

15 7 12 6 11 5 10 5 10 5

2. Тест: a₀ = 15, n = 10

  - Input:

15 10

  - Output:

20 10 15 7 12 6 11 5 10 5

3. Тест: a₀ = 1, n = 10

  - Input:

1 10

  - Output:

6 3 8 4 9 4 9 4 9 4

### 2. Задача 2

#### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ решения](#6-анализ-решения)

#### 1. Постановка задачи
Дана последовательность из n чисел. Необходимо найти длину и индекс начала самой длинной нестрого-монотонной подпоследовательности. Нестрого-монотонными считаются неубывающие и невозрастающие подпоследовательности.
#### 2. Входные и выходные данные
##### Данные на вход
|                          | Тип               | min значение | max значение |
|--------------------------|-------------------|--------------|--------------|
| Количество элементов (n) | Натуральное число |      1       |   1 00000    |
| Элемент 1                | Целое число       |    -10^9     |     10^9     |
|            ...           | Целое число       |    -10^9     |     10^9     |
| Элемент (n)              | Целое число       |    -10^9     |     10^9     |

##### Данные на выход
|               | Тип         | Описание                                                      |
|---------------|-------------|---------------------------------------------------------------|
| Длина         | Целое число | Длина самой длинной нестрого-монотонной подпоследовательности |
| Индекс начала | Целое число | Индекс начала подпоследовательности (1-индексированный)       |

#### 3. Выбор структуры данных
##### 1. Анализ: 
Для хранения последовательности и обработки данных нужен одномерный массив. Для отслеживания текущей и максимальной подпоследовательностей достаточно простых переменных-счетчиков.

##### 2. Структура данных:
- Одномерный массив типа `int` для хранения последовательности чисел
- Переменные типа `int` для хранения:
- текущей длины подпоследовательности
- текущего индекса начала
- максимальной длины
- индекса начала максимальной подпоследовательности
- типа монотонности
#### 4. Алгоритм
##### 1. Ввод данных:
   - Считать число n
   - Считать n целых чисел в массив

##### 2. Инициализация:
   - Если n = 0, вывести "0 0"
   - Установить начальные значения:
     - maxLength = 1
     - maxStartIndex = 0
     - currentLength = 1
     - currentStart = 0
     - monotonicType = 0 (0 - не определена, 1 - неубывающая, -1 - невозрастающая)

##### 3. Обработка последовательности (для i от 1 до n-1):
   - Сравнить arr[i] с arr[i-1]
   - Если тип монотонности не определен:
     - Определить тип по сравнению
     - Увеличить currentLength
   - Если тип соответствует текущей монотонности:
     - Увеличить currentLength
   - Иначе:
     - Обновить maxLength и maxStartIndex при необходимости
     - Начать новую подпоследовательность с i-1
     - Определить новый тип монотонности

##### 4. Проверка последней подпоследовательности:
Обновить maxLength и maxStartIndex при необходимости

##### 5. Вывод результата:
Вывести maxLength и (maxStartIndex + 1)

#### 5. Программа
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        if (n == 0) {
            System.out.println("0 0");
            return;
        }
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int maxLength = 1; 
        int startIndex = 0; 
        int currentStart = 0; 
        int currentLength = 1; 
        int monotonicType = 0;
        for (int i = 1; i < n; i++) {
            if (arr[i] > arr[i - 1]) {
                if (monotonicType == 0 || monotonicType == 1) {
                    monotonicType = 1;
                    currentLength++;
                } else {
                    if (currentLength > maxLength) {
                        maxLength = currentLength;
                        startIndex = currentStart;
                    }
                    currentStart = i - 1;
                    currentLength = 2;
                    monotonicType = 1;
                }
            } else if (arr[i] < arr[i - 1]) {
                if (monotonicType == 0 || monotonicType == -1) {
                    monotonicType = -1;
                    currentLength++;
                } else {
                    if (currentLength > maxLength) {
                        maxLength = currentLength;
                        startIndex = currentStart;
                    }
                    currentStart = i - 1;
                    currentLength = 2;
                    monotonicType = -1;
                }
            } else {
                currentLength++;
            }
        }
        if (currentLength > maxLength) {
            maxLength = currentLength;
            startIndex = currentStart;
        }
        System.out.println(maxLength + " " + (startIndex + 1));
        scanner.close();
    }
}
```
#### 6. Анализ решения:
Программа корректно работает для всех случаев:

1. Тест: Все элементы одинаковы

  - Input:

5 1 1 1 1 1

  - Output:

5 1

2. Тест: Строго возрастающая последовательность

  - Input:

5 1 2 3 4 5

  - Output:

5 1

3. Тест: Строго убывающая последовательность

  - Input:

5 5 4 3 2 1

  - Output:

5 1

4. Тест: Смешанная последовательность

  - Input:

8 1 2 3 3 2 1 1 2

  - Output:

4 1 (подпоследовательность 1, 2, 3, 3)

5. Тест: Чередование монотонности

  - Input:

10 1 2 3 2 1 0 -1 -2 -1 0

  - Output:

5 5 (подпоследовательность 1, 0, -1, -2, -1)

6.Тест: Один элемент

  - Input:

1 42

  - Output:

1 1

7.Тест: Пустая последовательность

  - Input:

0

  - Output:

0 0

### 3. Задача 3

#### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ решения](#6-анализ-решения)

#### 1. Постановка задачи

Дана стартовая месячная цена услуги C рублей. Каждый месяц цена индексируется: увеличивается на p% и округляется до целого числа рублей. Необходимо определить:
1. Через сколько полных лет годовая стоимость впервые превысит бюджет M
2. Сумму платежей в этот год

#### 2. Входные и выходные данные

##### Данные на вход
Три целых числа:
- C - стартовая месячная цена услуги
- p - процент индексации
- M - бюджет

| Параметр | Тип         | Диапазон значений | Описание                         |
|----------|-------------|-------------------|----------------------------------|
| C        | Целое число | 1 ≤ C ≤ 10^6      | Стартовая месячная цена в рублях |
| p        | Целое число | 1 ≤ p ≤ 100       | Процент индексации в месяц       |
| M        | Целое число | 1 ≤ M ≤ 10^9      | Годовой бюджет в рублях          |

##### Данные на выход
Два целых числа:
1. Количество полных лет
2. Сумма платежей в этот год

| Параметр | Тип         | Описание                                    |
|----------|-------------|---------------------------------------------|
| Годы     | Целое число | Количество полных лет до превышения бюджета |
| Сумма    | Целое число | Сумма платежей в год превышения бюджета     |


#### 3. Выбор структуры данных

##### 1. Анализ: 
Для решения задачи достаточно простых переменных для хранения текущих значений и счетчиков. Нет необходимости использовать сложные структуры данных.

##### 2. Структура данных:
- Переменные типа `long` для:
     - Текущей месячной цены
     - Суммы платежей за текущий год
     - Общей суммы за год
- Переменные типа `int` для:
     - Счетчика лет
     - Счетчика месяцев
- Переменные для хранения входных данных: C, p, M

#### 4. Алгоритм

##### 1. Инициализация:
- Считать входные данные C, p, M
- Инициализировать:
     - currentPrice = C (текущая месячная цена)
     - years = 0 (счетчик полных лет)
     - continueProcess = true (флаг продолжения цикла)

##### 2. Основной цикл (пока годовая сумма ≤ M):
  - Обнулить сумму за текущий год
  - Для каждого месяца (12 месяцев):
     - Добавить currentPrice к сумме за год
     - Вычислить новую цену на следующий месяц:
       - Увеличить currentPrice на p%
       - Округлить до целого: currentPrice = Math.round(currentPrice * (1 + p/100.0))
   - Увеличить счетчик лет на 1
   - Проверить, превысила ли годовая сумма бюджет M

##### 3. Определение результата:
   - Количество лет = years
   - Сумма платежей в год превышения = годовая сумма

#### 5. Программа
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int C = scanner.nextInt(); 
        int p = scanner.nextInt(); 
        int M = scanner.nextInt(); 
        double currentPrice = C; 
        int years = 0;           
        long yearlySum = 0;      
        boolean found = false;   
        while (!found) {
            yearlySum = 0;
            for (int month = 0; month < 12; month++) {
                yearlySum += Math.round(currentPrice);
                currentPrice = currentPrice * (1 + p / 100.0);
            }
            years++;
            if (yearlySum > M) {
                found = true; 
            }
        }
        System.out.println(years + " " + yearlySum);
        scanner.close();
    }
}
```
#### 6. Анализ решения:
1. Тест: Базовый случай
  - Input: 1000 10 150000

  - Расчет:

Год 1: 12 месяцев по ≈1000-3100 = ~24500 (< 150000)

Год 2: 12 месяцев по ≈3400-9400 = ~76800 (< 150000)

Год 3: 12 месяцев по ≈10300-27000 = ~223800 (> 150000)

  - Output: 3 223800

2. Тест: Быстрое превышение
  - Input: 10000 50 100000

  - Расчет:

Год 1: 12 месяцев по ≈10000-113906 = уже > 100000

  - Output: 1 581219

3. Тест: Медленный рост
  - Input: 1000 1 20000

  - Расчет:

Год 1: ~12126 (< 20000)

Год 2: ~13671 (< 20000)

Год 3: ~15412 (< 20000)

Год 4: ~17375 (< 20000)

Год 5: ~19591 (< 20000)

Год 6: ~22090 (> 20000)

  - Output: 6 22090

4. Тест: Граничные значения
  - Input: 1 100 1000000000 (минимальная цена, максимальный процент)

  - Расчет: Очень быстрый рост, превышение в первый год

  - Output: 1 [очень большое число]

5. Тест: Высокая начальная цена
  - Input: 1000000 1 12000000

  - Расчет:

Год 1: ≈12682530 (> 12000000)

  - Output: 1 12682530

6. Тест: Нулевое превышение (невозможно по условию)
  - Input: 1000 0 12000

  - Расчет: Цена не меняется, годовая сумма всегда 12000

  - Output: 1 12000 (превышения не будет, но цикл завершится после первого года)

### 4. Задача 4

#### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ решения](#6-анализ-решения)

#### 1. Постановка задачи

Дан массив из n чисел. Необходимо найти индекс первого элемента, после удаления которого массив станет упорядочен по неубыванию (каждый следующий элемент ≥ предыдущего). Если это невозможно, вывести "NO".

#### 2. Входные и выходные данные

##### Данные на вход
| Параметр | Тип         | Диапазон значений  | Описание                       |   
|----------|-------------|--------------------|--------------------------------|
| n        | Целое число | 1 ≤ n ≤ 10^5       | Количество элементов в массиве |
| a_i      | Целое число | -10^9 ≤ a_i ≤ 10^9 | Элементы массива               |

##### Данные на выход
| Параметр  | Тип                    | Значения                | Описание                              | 
|-----------|------------------------|-------------------------|---------------------------------------|
| Результат | Целое число или строка | 1 ≤ индекс ≤ n или "NO" | Индекс элемента для удаления или "NO" |


#### 3. Выбор структуры данных

##### 1. Анализ: 
Для решения задачи необходим массив для хранения исходной последовательности и проверки условий упорядоченности

##### 2. Структура данных:
- Одномерный массив типа `int` для хранения элементов
- Переменные для хранения:
     - Индексов нарушений порядка
     - Флагов результатов проверок

#### 4. Алгоритм

##### 1. Инициализация:
- Считать n
- Считать массив arr

##### 2. Поиск индексов нарушения порядка:
  - Пройти по массиву и найти все индексы i, где arr[i] > arr[i+1]
  - Если нарушений нет, массив уже упорядочен → вывести 1 (любой элемент можно удалить)
  - Если нарушений > 2, вывести "NO" (нужно удалить более одного элемента)

##### 3. Проверка возможных кандидатов:
    - Для каждого индекса нарушения k:
     - Проверить, можно ли удалить arr[k] (элемент перед нарушением)
     - Проверить, можно ли удалить arr[k+1] (элемент после нарушения)

##### 4. Проверка упорядоченности после удаления:
- Для каждого кандидата создать проверочный массив без этого элемента
- Проверить, упорядочен ли он по неубыванию
  
##### 5. Выбор первого подходящего индекса:
- Если найдено несколько подходящих элементов, выбрать с минимальным индексом
- Если не найдено ни одного, вывести "NO"

#### 5. Программа
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int result = -1;
        for (int i = 0; i < n; i++) {
            if (isSortedAfterRemoval(arr, i)) {
                result = i + 1;
                break;
            }
        }
        if (result == -1) {
            System.out.println("NO");
        } else {
            System.out.println(result);
        }
        scanner.close();
    }
    private static boolean isSortedAfterRemoval(int[] arr, int removeIndex) {
        int n = arr.length;
        int prev = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (i == removeIndex) {
                continue; 
            }
            if (arr[i] < prev) {
                return false;
            }
            prev = arr[i];
        }
        return true;
    }
}
```
#### 6. Анализ решения:
1. Тест. Уже упорядоченный массив (любой элемент можно удалить):
  - Input:
5
1 2 3 4 5

  - Output
1

2. Тест. Один элемент:

  - Input:
1
42

  - Output
1


3. Тест. Простое нарушение, исправляемое удалением одного элемента:

  - Input:
5
1 2 5 3 4

  - Output
3

4. Тест. Удаление последнего элемента:

  - Input:
4
1 2 3 0

  - Output
4

5. Тест. Несколько элементов одинаковые:

  - Input:
4
2 2 2 1

  - Output
4
